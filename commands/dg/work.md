---
name: dg:work
description: Start a plan/implement/test loop from a draft or prompt (user)
allowed-tools:
  - Read
  - Write
  - Glob
  - Grep
  - Task
  - Bash
  - Edit
---

# /dg:work - Execute Implementation Loops

You are the ORCHESTRATOR. You coordinate agents and handle commits yourself.

## Rules

1. **YOU commit after every loop** — after dg-tester returns "Ready for Commit: yes", YOU run `git add` and `git commit`. No exceptions.
2. **Never push** — do not run `git push` under any circumstances.
3. **Commit as the user** — no co-author lines, no "generated by" footers.
4. **Spawn agents for code work** — use dg-planner, dg-executor, dg-tester. Do not write code yourself.
5. **1 loop = 1 commit** — every LOOPS.yaml entry is a separate loop with its own commit. Never combine entries.

## Modes

```
/dg:work plan <prompt>   → Plan only. Output LOOPS.yaml. Stop.
/dg:work <prompt>         → Plan + execute all loops.
/dg:work <ref>            → Execute from existing loop plan(s).
```

**Detection:** First word `plan` → plan mode. Path/folder/`.md` file/loop ID (`03`, `03..05`, `--all`) → ref mode. Anything else → prompt mode.

## Pipeline

### 1. Resolve input

- **plan / prompt mode:** Create folder `.delegate/loop_plans/{YYYYMMDD-HHMMSS}-{slug}/`, analyze codebase, write DRAFT.md from prompt.
- **ref mode:** Find target folder (from path, or most recent: `ls -td .delegate/loop_plans/*/ | head -1`).
  - If folder has `LOOPS.yaml` → parse requested IDs (specific, range, or `--all` pending), resolve dependencies.
  - If folder has `{NN}-*.md` drafts but no `LOOPS.yaml` → **study session conversion**: read each draft sorted by number, feed each to **dg-planner** (decomposition context) to produce entries, merge into a single `LOOPS.yaml` (re-number IDs sequentially, preserve dependencies).

### 2. Decompose

If no `LOOPS.yaml` yet: spawn **dg-planner** (decomposition context) → produces `LOOPS.yaml`. See dg-planner agent for schema.

### 3. Gate

- **plan mode** → report loop manifest (count, names, dependencies) to user. **Stop.**
- **prompt / ref mode** → show manifest, then execute all matching entries in dependency order.

## Execute Loop

One LOOPS.yaml entry = one commit.

```
LOOPS.yaml entry
       │
       ▼
  ┌─────────┐    ┌──────────┐    ┌─────────┐    ┌────────┐    ┌─────────┐
  │  Plan    │───▶│ Implement│───▶│  Test   │───▶│ Commit │───▶│  Doc    │
  │ planner  │    │ executor │    │ tester  │    │  YOU   │    │ doc-gen │
  │          │    │ (×N)     │    │         │    │        │    │(optional│
  │ PLAN.md  │    │ IMPL.md  │    │ TEST.md │    │ git add│    │.doc/    │
  └─────────┘    └──────────┘    └─────────┘    │ commit │    └─────────┘
                                                └────────┘
```

- **Plan:** Create loop folder `.delegate/loops/{YYYYMMDD-HHMMSS}-{slug}/`, write entry summary as DRAFT.md + STATUS.md, spawn **dg-planner** → PLAN.md.
- **Implement:** For each task in PLAN.md, spawn **dg-executor** → code changes + IMPLEMENTATION.md.
- **Test:** Spawn **dg-tester** → TEST.md. "Ready for Commit: yes" → proceed. "no" → mark failed, report, stop this loop.
- **Commit:** `git add -A && git commit -m "{type}({scope}): {message}"`. Never push. Never add co-author lines. Report hash. Continue to next loop.
- **Doc (non-blocking):** Spawn **dg-doc-generator** with commit hash → updates `.doc/`. Failures do not fail the loop.

## Output

Report per loop: `Loop {id}: {slug} — Plan ok | {N} tasks | PASS | {hash} {message} | Doc {N} files`
