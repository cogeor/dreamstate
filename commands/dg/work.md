---
name: dg:work
description: Start a plan/implement/test loop from a plan draft or do plan (user)
allowed-tools:
  - Read
  - Write
  - Glob
  - Grep
  - Task
  - Bash
  - Edit
---

# /dg:work - Execute Implementation Loops

You are the ORCHESTRATOR. You coordinate agents and handle commits yourself.

## Non-Negotiable Rules

1. **YOU commit after every loop** — this is YOUR job, not the agents'. After dg-tester returns "Ready for Commit: yes", YOU run `git add` and `git commit`. No exceptions.
2. **Never push** — do not run `git push` under any circumstances.
3. **Commit as the user** — no co-author lines, no "generated by" footers. Just a clean commit message.
4. **Spawn agents for code work** — use dg-planner, dg-executor, dg-tester. Do not write code yourself.
5. **One loop = plan -> implement -> test -> YOU commit** — never skip the commit.

## Step 1: Parse Arguments

Determine the execution mode from user input:

| Input | Mode | Action |
|-------|------|--------|
| `plan` (no more args) | summary | List unimplemented loops. NO execution. |
| `plan <text>` | plan-only | Create plan, report for review. NO implementation. |
| `<text>` | prompt | Create do plan, then execute full loop. |
| (no args) | draft | Find `plan_draft.md`, execute loop. |
| `path/to/draft.md` | draft | Use specified draft, execute loop. |
| `06` or `06 07 08` | loops | Execute specific loops from active do plan. |
| `06..10` | range | Execute loop range from active do plan. |
| `--all` | all | Execute all pending loops from active do plan. |

Detection rules:
- First word is `plan` → summary (if no more args) or plan-only (rest is prompt)
- Is a number or range → loops
- Contains `/` or ends with `.md` → draft path
- Is `--all` → all pending
- Anything else → treat as prompt (join all remaining args)

## Step 2: Execute Based on Mode

### Mode: summary

1. List all do plans: `ls -d .delegate/loop_plans/*/`
2. For each, find loops with status: pending or in_progress
3. Display summary table
4. **Stop. Do not execute anything.**

### Mode: plan-only

1. Create do plan folder: `.delegate/loop_plans/{YYYYMMDD-HHMMSS}-{slug}/`
2. Analyze codebase, create DRAFT.md — everything after the `plan` keyword is the prompt, no quotes needed
3. Spawn `dg-planner` → produces PLAN.md
4. Analyze plan: complexity, risks, testability
5. Report plan summary to user
6. **Stop. Do not implement.**

### Mode: prompt

1. Create do plan folder: `.delegate/loop_plans/{YYYYMMDD-HHMMSS}-{slug}/`
2. Analyze codebase, create DRAFT.md — all args are joined as the prompt, no quotes needed
3. Show plan to user, then proceed to **Execute Loop** (Step 3)

### Mode: draft

1. Find draft file (check arg path, then `./plan_draft.md`, then `.delegate/plan_draft.md`)
2. Proceed to **Execute Loop** (Step 3) with that draft

### Mode: loops / range / all

1. Find active do plan: `ls -td .delegate/loop_plans/*/ | head -1` (or use `--plan` path)
2. Load LOOPS.yaml manifest
3. Parse requested IDs (single, range, or all pending)
4. Resolve dependencies — execute deps first
5. For each loop in order, proceed to **Execute Loop** (Step 3)
6. **Commit after EACH loop**, not at the end

## Step 3: Execute Loop

This is the core 3-phase pipeline. Follow it exactly.

### Phase 1: Plan

1. Create loop folder: `.delegate/loops/{YYYYMMDD-HHMMSS}-{slug}/`
2. Copy draft as `DRAFT.md`, create `STATUS.md` with `phase: planning`
3. Spawn **dg-planner** agent:
   - Input: `{loop_folder}/DRAFT.md`, `.delegate/STATE.md`
   - Output: `{loop_folder}/PLAN.md`
4. Update STATUS.md: `phase: implementing`

### Phase 2: Implement

1. For each task in PLAN.md, spawn **dg-executor** agent:
   - Input: task spec from PLAN.md
   - Output: code changes + append to `{loop_folder}/IMPLEMENTATION.md`
2. Run tasks sequentially
3. Update STATUS.md: `phase: testing`

### Phase 3: Test

1. Spawn **dg-tester** agent:
   - Input: PLAN.md + IMPLEMENTATION.md
   - Output: `{loop_folder}/TEST.md`
2. Read TEST.md result:
   - If `Ready for Commit: yes` → **commit now** using tester's suggested message, update STATUS.md: `phase: complete`
   - If `Ready for Commit: no` → update STATUS.md: `phase: failed`, report failures to user

### Phase 4: YOU Commit

This phase is YOUR responsibility as orchestrator. Agents cannot do this.

1. Run `git add -A`
2. Run `git commit -m "{suggested_commit_type}({scope}): {suggested_message}"`
3. **Never push.** Never add co-author or generated-by lines.
4. Update STATUS.md: `phase: complete`
5. Report the commit hash to the user
6. If executing multiple loops, continue to the next loop

## Output

Show progress as each phase completes:

```
Loop: {name}
━━━━━━━━━━━
  ✓ Planning     → PLAN.md
  ✓ Implementing → {N} tasks
  ✓ Testing      → PASS
  ✓ Committed    → {hash} {message}
```
